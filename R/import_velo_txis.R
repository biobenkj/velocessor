#' import Alevin velocity information (per-run) into a SingleCellExperiment
#'
#' This function is usually called by process_velo_txis(). The 'cdat' argument
#' takes a single-row data.frame containing 'names' and 'files' as its columns. 
#' 'cg' is a feature mapping for spliced and unspliced versions of the same 
#' gene (transcript group), as generated by eisaR for tximeta. 'asy' is best 
#' left untouched -- using scaled TPMs ('abundance') works quite well for down-
#' stream filtering and QC. 'sep' is just the glue for disambiguating cell 
#' barcodes by sample so that they can be merged via cbind without incident 
#' once the results of import_velo_txis are returned to process_velo_txis.
#' 
#' @param   cdat  A row of the colData prepared by process_velo_txis.
#' @param   cg    A data.frame with columns 'spliced' and 'unspliced' per gene.
#' @param   QC    Perform rudimentary quality control? (TRUE) 
#' @param   asy   What to load into counts/spliced/unspliced? ("abundance")
#' @param   sep   What string separates sample name from barcode? ("_")
#' 
#' @return        A SingleCellExperiment with 'spliced' and 'unspliced' assays.
#' 
#' @import scran 
#' @import scater 
#' @import scuttle
#' @import tximeta
#' @import MatrixGenerics
#' @import SingleCellExperiment
#' 
#' @export
import_velo_txis <- function(cdat, cg, QC=FALSE, asy="abundance", sep="_") {

  stopifnot(length(cdat['names']) == 1)
  cfroma <- ifelse(asy == "abundance", "scaledTPM", "no")

  message("Processing ", cdat['names'], "...")
  txi_cdat <- data.frame(names=cdat['names'], files=cdat['files'])

  message("Importing...")
  txi <- tximeta(coldata=txi_cdat, countsFromAbundance=cfroma,  type="alevin")

  message("Renaming...")
  colnames(txi) <- paste(cdat['names'], colnames(txi), sep=sep)
  colData(txi)$numTranscripts <- colSums(assay(txi, "counts")) # for TPM'ing

  message("Splitting...")
  print(system.time(txis <- tximeta::splitSE(txi, cg, assayName="counts")))

  message("Converting...")
  print(system.time(txis <- as(txis, "SingleCellExperiment")))
  print(assayNames(txis))
  assays(txis) <- list(counts=assays(txis)[["spliced"]],
                       spliced=assays(txis)[["spliced"]],
                       unspliced=assays(txis)[["unspliced"]])
  colData(txis)$countsFromTpm <- (asy == "abundance")

  # stupid simple QC
  if (QC) {
    message("QCing...")
    print(system.time(txis <- .doQC(txis)))
  } else { 
    message("adding logNormCounts...")
    print(system.time(txis <- scuttle::logNormCounts(txis)))
  } 

  message("Done.")
  return(txis) 

}


# helper fn
.doQC <- function(txis, verbose=FALSE) { 

  if (verbose) message("Starting QC...")
  qcstats <- scuttle::perCellQCMetrics(txis)
  qcfilter <- scuttle::quickPerCellQC(qcstats)
  txis <- txis[, !qcfilter$discard]
  if (verbose) message(length(qcfilter$discard), " cells dropped")
  txis <- scuttle::logNormCounts(txis)
  colData(txis)$QCed <- TRUE
  return(txis)

}
